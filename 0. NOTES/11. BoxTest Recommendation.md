# BoxText() Changes

Of course! These are excellent and powerful additions. Adding custom widths, separate text coloring, and text alignment will turn `BoxText` into a highly professional and reusable utility.

Let's implement these changes. We'll need to update the options interface and then significantly refactor the `BoxText` function to handle the more complex rendering logic.

## 1. Update the `BoxTextOptions` Interface

First, we'll add the new properties to `BoxTextOptions` in `PrintLine.ts`.

```typescript
// In PrintLine.ts

interface BoxTextOptions {
    preNewLine?: boolean;
    postNewLine?: boolean;
    // Allow 'tight', 'max', or a specific number for the width
    width?: 'tight' | 'max' | number;
    boxStyle?: BoxStyle;
    
    // Box-specific styling
    color?: InspectColor | InspectColor[];
    bgColor?: InspectColor | InspectColor[];
    styles?: ('bold' | 'italic' | 'underline')[];

    // New! Text-specific styling
    textColor?: InspectColor | InspectColor[];
    textBgColor?: InspectColor | InspectColor[];
    textStyles?: ('bold' | 'italic' | 'underline')[];
}
```

## 2. Refactor the `BoxText` Function

This is the main part of the work. The old implementation styled the entire box at once. The new implementation must build the box in styled pieces (top border, left border, text, right border, bottom border) to allow for different colors.

Here is the complete, refactored `BoxText` function.

```typescript
// In PrintLine.ts, replace your old BoxText function with this one.

/**
 * @function BoxText
 * @description Draws a styled ASCII box around a given text string and prints it to the console.
 * @param {string} text - The text to be enclosed in the box.
 * @param {BoxTextOptions} [options={}] - Configuration options for the box.
 * @returns {void}
 */
export const BoxText = (text: string, options: BoxTextOptions = {}): void => {
    // --- 1. Set Defaults and Merge Options ---
    const {
        preNewLine = false,
        postNewLine = false,
        width = 'tight',
        boxStyle = 'single',
        color,
        bgColor,
        styles,
        textColor,
        textBgColor,
        textStyles,
    } = options;

    const boxChars = BOX_STYLES[boxStyle];

    // --- 2. Prepare Separate Styles for Box and Text ---
    const boxFinalStyles = [
        ...(color ? (Array.isArray(color) ? color : [color]) : []),
        ...(bgColor ? (Array.isArray(bgColor) ? bgColor : [bgColor]) : []),
        ...(styles || []),
    ];
    
    // If text styles aren't provided, they default to the box styles
    const textFinalStyles = [
        ...(textColor ? (Array.isArray(textColor) ? textColor : [textColor]) : boxFinalStyles),
        ...(textBgColor ? (Array.isArray(textBgColor) ? textBgColor : [textBgColor]) : []),
        ...(textStyles || []),
    ];


    // --- 3. Calculate Content Width and Wrap Text ---
    let contentWidth: number;
    let textLines: string[];

    if (width === 'max') {
        contentWidth = MAX_WIDTH - 4; // 80 - 2 for borders - 2 for padding
    } else if (typeof width === 'number') {
        if (width <= 4) throw new Error('Custom width must be greater than 4.');
        contentWidth = width - 4;
    } else { // 'tight'
        textLines = text.split('\n');
        contentWidth = Math.max(...textLines.map(line => line.length));
    }

    // Word-wrap the text if width is 'max' or a number
    if (width !== 'tight') {
        const words = text.split(/\s+/);
        textLines = words.reduce((lines, word) => {
            if (lines.length === 0) return [word];
            let lastLine = lines[lines.length - 1];
            if ((lastLine.length + word.length + 1) > contentWidth) {
                lines.push(word);
            } else {
                lines[lines.length - 1] = lastLine + ' ' + word;
            }
            return lines;
        }, [] as string[]);
    }


    // --- 4. Build the Box with Piece-by-Piece Styling ---
    
    // Helper to center-align text
    const centerAlign = (str: string, width: number): string => {
        const padding = Math.floor((width - str.length) / 2);
        return ' '.repeat(padding) + str + ' '.repeat(width - str.length - padding);
    };

    // Style the border components
    const styledTop = styleText(boxFinalStyles, boxChars.tl + boxChars.t.repeat(contentWidth + 2) + boxChars.tr);
    const styledBottom = styleText(boxFinalStyles, boxChars.bl + boxChars.b.repeat(contentWidth + 2) + boxChars.br);
    const styledLeftBorder = styleText(boxFinalStyles, boxChars.l + ' ');
    const styledRightBorder = styleText(boxFinalStyles, ' ' + boxChars.r);

    // Style each line of text and assemble with borders
    const styledContentLines = textLines.map(line => {
        const centeredText = centerAlign(line, contentWidth);
        const styledText = styleText(textFinalStyles, centeredText);
        return styledLeftBorder + styledText + styledRightBorder;
    });

    const fullBoxString = [
        styledTop,
        ...styledContentLines,
        styledBottom
    ].join('\n');

    // --- 5. Print Final Output ---
    const pre = preNewLine ? '\n' : '';
    const post = postNewLine ? '\n' : '';
    console.log(`${pre}${fullBoxString}${post}`);
};
```

## How the New Logic Works

1. **Separate Style Preparations:** The code now creates two distinct style arrays: `boxFinalStyles` and `textFinalStyles`. Crucially, if you don't provide a `textColor`, the `textFinalStyles` will default to using the `boxFinalStyles`, so it still looks good out-of-the-box.
2. **Flexible Width Calculation:** The logic now correctly handles all three cases for `width`:
    * **`'max'`**: Sets a fixed `contentWidth` of 76.
    * **`number`**: Sets the `contentWidth` based on your number, ensuring it's valid.
    * **`'tight'`**: Calculates the `contentWidth` based on the longest line of text *after* splitting by newlines.
3. **Unified Word Wrapping:** The word-wrap logic is now correctly applied for both `'max'` and `number` widths.
4. **Centering and Piece-by-Piece Styling:** This is the biggest change.
    * A new `centerAlign` helper function ensures every line of text is perfectly centered within the `contentWidth`.
    * Instead of building one giant string and styling it at the end, it now styles the **top border**, **left border**, **text**, **right border**, and **bottom border** as separate pieces.
    * It then joins these pre-styled pieces together to create the final visual output. This is the key to allowing the text and border to have different styles.

## New Usage Examples

You can now use your function in these powerful new ways:

```typescript
// --- Custom Width with Centered Text ---
BoxText('This box has a custom width of 50.', {
    width: 50,
    boxStyle: 'double',
    preNewLine: true,
    postNewLine: true,
});

// --- Custom Text Color ---
BoxText('This text is a different color from the border.', {
    width: 'max',
    color: 'gray', // Border color
    textColor: 'cyan', // Text color
    preNewLine: true,
    postNewLine: true,
});

// --- Complex Example: Themed Box with Styled Text ---
const longText = 'This demonstrates all features: a custom width, a heavy box style, a gray border, and bold, centered, yellow text inside.';
BoxText(longText, {
    width: 60,
    boxStyle: 'heavy',
    color: 'gray',
    textColor: 'yellow',
    textStyles: ['bold'],
    preNewLine: true,
    postNewLine: true,
});
```

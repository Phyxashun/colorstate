# Annex F. Parsing Character Classes

It is reasonably straightforward to build a parser for Character Classes. While there are many ways to do this, the following describes one example of a logical process for building such a parser. Implementations can use optimized code, such as a DFA (Deterministic Finite Automaton) for processing.

## Storage

The description uses Java syntax to illustrate the code, but of course would be expressed in other programming languages. At the core is a class (here called CharacterClass) that stores the information that is being built, typically a set of strings optimized for compact storage of ranges of characters, such as ICU’s UnicodeSet (C++).

The methods needed are the following:

| Method                                        | Meaning                       |
|:----------------------------------------------|:------------------------------|
| CharacterClass create()                       | A = {}                        |
| void addAll(CharacterClass other)             | A = A ∪ other                 |
| void retainAll(CharacterClass other)          | A = A ∩ other                 |
| void removeAll(CharacterClass other)          | A = A ∖ other                 |
| void symmetricDiffAll(CharacterClass other)   | A = A ⊖ other                 |
| void add(int cp)                              | A = A ∪ {cp}                  |
| void addRange(int cpStart, int cpEnd)         | A = A ∪ {cpStart .. cpEnd}    |
| void addString(String stringToAdd)            | A = A ∪ {stringToAdd}         |
| void codePointComplement()                    | A = ∁ℙA                       |
| void setToProperty(String propertyString)     | A = propertySet               |

## Building

At the top level a method parseCharacterClass can recognize and branch on ‘\p{’, ‘\P{’, ‘[’, and ‘[^’ . For ‘\p{’ and ‘\P{’, it calls a parseProperty method that parses up to an unescaped ‘}’, and returns a set based on Unicode properties. See RL1.2 Properties, 2.7 Full Properties, RL2.7 Full Properties, and 2.8 Optional Properties.

For ‘[’, and ‘[^’, it calls a parseSequence method that parses out items, stopping when it hits ‘]’. The type of each item can be determined by the initial characters. There is a special check for ‘-’ so that it can be interpreted according to context. The targetSet is set to the first item. All successive items at that level are combined with the targetSet, according to the specified operation (union, intersection, etc.). Note that other binding/precedence options would require somewhat more complicated parsing.

For the Character Class item, a recursive call is made on the parseCharacterClass method. The other initial characters that are branched on are ‘\u{’, ‘\u’, ‘\q{’, ‘\N{’, ‘\’, the operators, and literal and escaped characters.

### Examples

In the following examples, ➗  is a cursor marking how the parsing progresses. For brevity, intermediate steps that only change state are omitted. The two examples are the same, except that in the right-hand example the second and third character classes are grouped.

#### Example 1: No Grouping

| Input                            | Action                | Result    |
|:---------------------------------|:----------------------|:----------|
| ➗[[abc] -- [bcd] && [c-e]]      | A = create()          | A = []    |
| [[a➗bc] -- [bcd] && [c-e]]      | A.add('a')            | A = [a]   |
| [[ab➗c] -- [bcd] && [c-e]]      | A.add('b')            | A = [ab]  |
| [[abc➗] -- [bcd] && [c-e]]      | A.add('c')            | A = [a-c] |
| [[abc] -- ➗[bcd] && [c-e]]      | B = create()          | A = [a-c] |
| [[abc] -- [b➗cd] && [c-e]]      | B.add('b')            |           |
| [[abc] -- [bc➗d] && [c-e]]      | B.add('c')            | B = [b-c] |
| [[abc] -- [bcd➗] && [c-e]]      | B.add('d')            | B = [b-d] |
| [[abc] -- [bcd]➗ && [c-e]]      | A.removeAll(B)        | A = [a]   |
| [[abc] -- [bcd] && ➗[c-e]]      | B.clear()             | B = []    |
| [[abc] -- [[bcd] && [c➗-e]]]    | B.add('c')            | B = [c]   |
| [[abc] -- [[bcd] && [c-e➗]]]    | B.addRange('d', 'e')  | B = [c-e] |
| [[abc] -- [[bcd] && [c-e]➗]]    | A.retainAll(C)        | A = []    |

#### Example 2: With Grouping

| Input                              | Action                | Result    |
|:-----------------------------------|:----------------------|:----------|
| ➗[[abc] -- [[bcd] && [c-e]]]      | A = create()          | A = []    |
| [[a➗bc] -- [[bcd] && [c-e]]]      | A.add('a')            | A = [a]   |
| [[ab➗c] -- [[bcd] && [c-e]]]      | A.add('b')            | A = [ab]  |
| [[abc➗] -- [[bcd] && [c-e]]]      | A.add('c')            | A = [a-c] |
| [[abc] -- ➗[[bcd] && [c-e]]]      | B = create()          | A = [a-c] |
| [[abc] -- [[b➗cd] && [c-e]]]      | B.add('b')            |           |
| [[abc] -- [[bc➗d] && [c-e]]]      | B.add('c')            | B = [b-d] |
| [[abc] -- [[bcd➗] && [c-e]]]      | B.add('d')            | B = [b-d] |
| [[abc] -- [[bcd]➗ && [c-e]]]      |                       |           |
| [[abc] -- [[bcd] && ➗[c-e]]]      | C = create()          | C = []    |
| [[abc] -- [[bcd] && [c➗-e]]]      | C.add('c')            | C = [c]   |
| [[abc] -- [[bcd] && [c-e➗]]]      | C.addRange('d', 'e')  | C = [c-e] |
| [[abc] -- [[bcd] && [c-e]➗]]      | B.retainAll(C)        | B = [cd]  |
| [[abc] -- [[bcd] && [c-e]]]➗      | A.removeAll(B)        | A = [ab]  |
